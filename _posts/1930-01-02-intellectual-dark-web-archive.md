---
layout: post
title:  "Intellectual Dark Web"
description: 
tags: Creation
---

### Life

> The most value comes from doing something no one else can do, or no one else has thought of, in a way that is hard for other people to copy.  If you try to be just like everyone else, and do just what they’re doing, you will maybe do ok but certainly not great. -[Sam Altman](https://twitter.com/sama/status/1214274049074814976?s=12)


> No man ever "found" himself. "Finding" yourself is a pop culture lie. As a man, you can only "make" yourself. No amount of travel, drugs, music, weird clothing, and learning foreign languages will help you "find yourself". There is nothing to find, only to create. -[source](https://twitter.com/lifemathmoney/status/1200572670309482506?s=12)

### Death

> "Remembering that I'll be dead soon is the most important tool I've ever encountered to help me make the big choices in life. Because almost everything — all external expectations, all pride, all fear of embarrassment or failure - these things just fall away in the face of death, leaving only what is truly important. Remembering that you are going to die is the best way I know to avoid the trap of thinking you have something to lose. You are already naked. There is no reason not to follow your heart." -Steve Jobs


> Common mistake: Overvaluing predicting the future, undervaluing understanding the present.  Overvaluing being accurate about the future instead of being directionally correct, and building optionality. -[source](https://twitter.com/kylebrussell/status/1258487654343204864)



### Programming 

> The quality of the team working on the project and the quality of their engineering practices are far more important than the language. Rust and Haskell offer similar levels of language features to help people write good code but they have different trade offs. An above average team in one of these languages would outperform a below average team on the other.


> Programming languages are languages, but only for a very restricted vocabulary that is not even close to what can be done on human languages. Also, being fluent in a human language involves not only reading and writing, but also talking. A word is an abstract concept given a definition in terms of other words. The equivalent of set of related words is an API in a programming language.

> Natural languages are intended and optimized for speaking, and they inherently encourage ambiguity because conversation is an interactive process where one can request clarification. Programming languages are typically non-interactive and don't tolerate ambiguity at all. in a programming language every vocable is clearly defined when used, or you get an error. Words in natural languages are not really clearly defined. There is only a very small subset of words, people are not fighting over their definition.


### Performence

> “The cost of your good habits is in the present. The cost of your bad habits is in the future.” – James Clear
